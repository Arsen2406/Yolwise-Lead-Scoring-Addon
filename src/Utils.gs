/**
 * Utility functions for testing, debugging, and maintenance
 * Yolwise Lead Scoring Add-on for Turkish B2B market
 * ADAPTED FROM SMARTWAY: Turkish business context and Yolwise API integration
 * Comprehensive header detection validation and Turkish market testing
 * Hybrid mapping system testing and validation
 */

/**
 * Setup wizard for first-time Yolwise configuration
 * Run this function after copying the code to your Apps Script project
 */
function setupYolwiseWizard() {
  Logger.log('üöÄ Yolwise Lead Scoring Setup Wizard v1.0 (Turkish B2B)');
  Logger.log('=======================================================');
  
  try {
    // Check if API keys are configured
    const claudeKey = getClaudeApiKey();
    const yolwiseKey = getYolwiseApiKey();
    const yolwiseUrl = getYolwiseApiUrl();
    
    Logger.log('üìã Yapƒ±landƒ±rma Durumu:');
    Logger.log(`Claude API Key: ${claudeKey ? '‚úì Yapƒ±landƒ±rƒ±ldƒ±' : '‚úó Eksik'}`);
    Logger.log(`Yolwise API Key: ${yolwiseKey ? '‚úì Yapƒ±landƒ±rƒ±ldƒ±' : '‚úó Eksik'}`);
    Logger.log(`Yolwise API URL: ${yolwiseUrl ? '‚úì ' + yolwiseUrl : '‚úó Eksik'}`);
    
    if (!claudeKey) {
      Logger.log('');
      Logger.log('‚ö†Ô∏è  Claude API Key Gerekli!');
      Logger.log('L√ºtfen √ßalƒ±≈ütƒ±rƒ±n: setupYolwiseApiKeysManual()');
      Logger.log('Veya anahtarƒ±nƒ±zƒ± alƒ±n: https://console.anthropic.com');
      return false;
    }
    
    if (!yolwiseKey) {
      Logger.log('');
      Logger.log('‚ö†Ô∏è  Yolwise API Key Gerekli!');
      Logger.log('Replit projenden API anahtarƒ±nƒ± al ve setupYolwiseApiKeysManual() √ßalƒ±≈ütƒ±r');
    }
    
    // Test API connections
    Logger.log('');
    Logger.log('üîß API Baƒülantƒ±larƒ± Test Ediliyor...');
    testYolwiseApiConnections();
    
    // Test with Turkish sample data
    Logger.log('');
    Logger.log('üß™ T√ºrk ≈ûirket Skorlama Testi √áalƒ±≈ütƒ±rƒ±lƒ±yor...');
    testTurkishScoring();
    
    // Run consistency validation
    Logger.log('');
    Logger.log('‚úÖ Sistem Tutarlƒ±lƒ±ƒüƒ± Doƒürulanƒ±yor...');
    validateYolwiseSystemConsistency();
    
    // Test Turkish header detection improvements
    Logger.log('');
    Logger.log('üîç T√ºrk ƒ∞≈ü Verisi Ba≈ülƒ±k Tespiti Test Ediliyor...');
    testTurkishHeaderDetection();
    
    // Test hybrid mapping system for Turkish context
    Logger.log('');
    Logger.log('üîÑ T√ºrk B2B Hibrit E≈üle≈ütirme Sistemi Test Ediliyor...');
    testTurkishHybridMappingSystem();
    
    Logger.log('');
    Logger.log('‚úÖ Kurulum Tamamlandƒ±!');
    Logger.log('Artƒ±k Google Sheets\'te eklentiyi kullanabilirsiniz');
    Logger.log('Git: Uzantƒ±lar ‚Üí Yolwise Lead Scoring');
    
    return true;
    
  } catch (error) {
    Logger.log('‚ùå Kurulum ba≈üarƒ±sƒ±z:', error);
    Logger.log('');
    Logger.log('üîç Sorun Giderme:');
    Logger.log('1. T√ºm dosyalarƒ± kopyaladƒ±ƒüƒ±nƒ±zdan emin olun (Code.gs, APIService.gs, TurkishDataExtractor.gs, index.html)');
    Logger.log('2. appsscript.json manifest dosyasƒ±nƒ±n doƒüru olduƒüunu kontrol edin');
    Logger.log('3. API anahtarlarƒ±nƒ±n d√ºzg√ºn ayarlandƒ±ƒüƒ±nƒ± doƒürulayƒ±n');
    return false;
  }
}

/**
 * Manual API keys setup function for Yolwise
 * Replace YOUR_KEYS with actual keys and run this function
 */
function setupYolwiseApiKeysManual() {
  const properties = PropertiesService.getScriptProperties();
  
  // REPLACE THESE WITH YOUR ACTUAL API KEYS
  const CLAUDE_API_KEY = 'sk-ant-api03-YOUR_CLAUDE_KEY_HERE';
  const YOLWISE_API_KEY = 'YOUR_YOLWISE_API_KEY_HERE'; // From Replit
  const YOLWISE_API_URL = 'https://yolwiseleadscoring.replit.app';
  
  if (CLAUDE_API_KEY.includes('YOUR_CLAUDE_KEY_HERE')) {
    Logger.log('‚ùå L√ºtfen YOUR_CLAUDE_KEY_HERE\'yi ger√ßek Claude API anahtarƒ±nƒ±zla deƒüi≈ütirin!');
    Logger.log('Anahtarƒ±nƒ±zƒ± alƒ±n: https://console.anthropic.com');
    return;
  }
  
  if (YOLWISE_API_KEY.includes('YOUR_YOLWISE_API_KEY_HERE')) {
    Logger.log('‚ùå L√ºtfen YOUR_YOLWISE_API_KEY_HERE\'yi ger√ßek Yolwise API anahtarƒ±nƒ±zla deƒüi≈ütirin!');
    Logger.log('Anahtarƒ± Replit projenizden alƒ±n');
    return;
  }
  
  // Set the keys
  properties.setProperty('CLAUDE_API_KEY', CLAUDE_API_KEY);
  properties.setProperty('YOLWISE_API_KEY', YOLWISE_API_KEY);
  properties.setProperty('YOLWISE_API_URL', YOLWISE_API_URL);
  
  Logger.log('‚úÖ T√ºm API anahtarlarƒ± yapƒ±landƒ±rƒ±ldƒ±');
  Logger.log('üöÄ ≈ûimdi √ßalƒ±≈ütƒ±rƒ±n: setupYolwiseWizard()');
}

/**
 * MISSING FUNCTION: Extract Turkish company data using structured mapping
 * @param {Array} row Row data from spreadsheet
 * @param {Array} headers Column headers
 * @returns {Object} Extracted company data
 */
function extractTurkishCompanyDataStructured(row, headers) {
  const data = {};
  
  try {
    // Enhanced field mappings with Turkish support
    const turkishFieldMappings = {
      'company_name': {
        keywords: ['≈üirket adƒ±', '≈üirket unvanƒ±', 'firma adƒ±', 'company name', 'company', 'name', 'firm'],
        maxLength: 200,
        required: true
      },
      'industry': {
        keywords: ['sekt√∂r', 'faaliyet sekt√∂r√º', 'i≈ü alanƒ±', 'industry', 'sector', 'business', 'field'],
        maxLength: 100,
        required: false
      },
      'revenue_estimate': {
        keywords: ['yƒ±llƒ±k gelir', 'yƒ±llƒ±k ciro', 'gelir', 'ciro', 'annual revenue', 'revenue', 'sales', 'turnover'],
        maxLength: 50,
        required: false,
        numeric: true
      },
      'employees_estimate': {
        keywords: ['√ßalƒ±≈üan sayƒ±sƒ±', 'personel sayƒ±sƒ±', 'i≈ü√ßi sayƒ±sƒ±', 'number of employees', 'employees', 'staff', 'workforce'],
        maxLength: 50,
        required: false
      },
      'headquarters': {
        keywords: ['≈üehir', 'il', 'merkez', 'merkez il', 'ana merkez', 'city', 'location', 'headquarters', 'head office'],
        maxLength: 100,
        required: false
      },
      'description': {
        keywords: ['a√ßƒ±klama', 'tanƒ±m', 'faaliyet', 'ana faaliyet', 'description', 'about', 'overview', 'summary'],
        maxLength: 1000,
        required: false
      }
    };
    
    const mappedHeaders = new Set();
    
    // Enhanced extraction with Turkish language support
    headers.forEach((header, index) => {
      if (!header || index >= row.length) return;
      
      const normalizedHeader = header.toString().toLowerCase().trim();
      const cellValue = row[index];
      
      // Skip empty or null values
      if (!cellValue || cellValue.toString().trim() === '') return;
      
      for (const [field, config] of Object.entries(turkishFieldMappings)) {
        if (config.keywords.some(keyword => normalizedHeader.includes(keyword))) {
          let processedValue = cellValue.toString().trim();
          
          // Apply security constraints
          if (config.maxLength && processedValue.length > config.maxLength) {
            processedValue = processedValue.substring(0, config.maxLength);
          }
          
          // Numeric validation for Turkish numbers
          if (config.numeric) {
            const numericValue = extractTurkishNumericValue(processedValue);
            processedValue = numericValue;
          }
          
          data[field] = processedValue;
          mappedHeaders.add(index);
          break;
        }
      }
    });
    
    // Enhanced categorization for unmapped Turkish fields
    const turkishCategories = {
      financial_data: [],
      legal_data: [], 
      operational_data: [],
      contact_data: [],
      other_data: []
    };
    
    headers.forEach((header, index) => {
      if (!mappedHeaders.has(index) && row[index] && row[index].toString().trim() !== '') {
        const headerLower = header.toString().toLowerCase().trim();
        const value = row[index].toString().trim();
        
        // Security: limit entry length
        const safeValue = value.length > 200 ? value.substring(0, 200) + '...' : value;
        const entry = `${header}: ${safeValue}`;
        
        // Enhanced Turkish categorization
        if (headerLower.includes('gelir') || headerLower.includes('ciro') || headerLower.includes('mali') || 
            headerLower.includes('revenue') || headerLower.includes('financial')) {
          turkishCategories.financial_data.push(entry);
        } else if (headerLower.includes('yasal') || headerLower.includes('lisans') || headerLower.includes('kayƒ±t') ||
                   headerLower.includes('legal') || headerLower.includes('license')) {
          turkishCategories.legal_data.push(entry);
        } else if (headerLower.includes('ileti≈üim') || headerLower.includes('telefon') || headerLower.includes('email') ||
                   headerLower.includes('contact') || headerLower.includes('phone')) {
          turkishCategories.contact_data.push(entry);
        } else if (headerLower.includes('operasyon') || headerLower.includes('≈üube') || headerLower.includes('ofis') ||
                   headerLower.includes('operation') || headerLower.includes('branch') || headerLower.includes('office')) {
          turkishCategories.operational_data.push(entry);
        } else {
          turkishCategories.other_data.push(entry);
        }
      }
    });
    
    // Combine categorized data with limits
    const discoveredFacts = [];
    Object.entries(turkishCategories).forEach(([category, items]) => {
      if (items.length > 0) {
        // Limit items per category for security
        const limitedItems = items.slice(0, 10);
        discoveredFacts.push(`${category}: ${limitedItems.join('; ')}`);
      }
    });
    
    data.discovered_facts = discoveredFacts;
    
    Logger.log(`‚úÖ Turkish structured extraction completed for: ${data.company_name || 'Unknown company'}`);
    
    return data;
    
  } catch (error) {
    Logger.log('‚ùå Error in Turkish structured extraction: ' + error.toString());
    return {
      company_name: 'Extraction Error',
      extraction_error: error.message
    };
  }
}

/**
 * MISSING FUNCTION: Extract numeric value from Turkish formatted text
 * @param {string} text Text containing potential numeric value
 * @returns {number} Extracted numeric value or 0
 */
function extractTurkishNumericValue(text) {
  try {
    if (typeof text === 'number') return Math.max(0, text);
    
    const textStr = text.toString().trim();
    
    // Handle Turkish multipliers
    let multiplier = 1;
    if (textStr.toLowerCase().includes('milyon') || textStr.toLowerCase().includes('million') || textStr.toLowerCase().includes('m')) {
      multiplier = 1000000;
    } else if (textStr.toLowerCase().includes('bin') || textStr.toLowerCase().includes('thousand') || textStr.toLowerCase().includes('k')) {
      multiplier = 1000;
    } else if (textStr.toLowerCase().includes('milyar') || textStr.toLowerCase().includes('billion') || textStr.toLowerCase().includes('b')) {
      multiplier = 1000000000;
    }
    
    // Extract first number (handle Turkish decimal separator)
    const match = textStr.replace(',', '.').match(/(\\d+(?:\\.\\d+)?)/);
    if (match) {
      return Math.max(0, parseFloat(match[1]) * multiplier);
    }
    
    return 0;
  } catch (error) {
    Logger.log('‚ùå Error extracting Turkish numeric value: ' + error.toString());
    return 0;
  }
}

/**
 * MISSING FUNCTION: Create mock scoring for Yolwise when API is unavailable
 * @param {Object} claudeAnalysis Claude analysis data
 * @returns {Object} Mock scoring result
 */
function createYolwiseMockScoring(claudeAnalysis) {
  Logger.log('üîß Creating Yolwise mock scoring for Turkish B2B market');
  
  try {
    // Enhanced Turkish industry modifiers
    const turkishIndustryModifiers = {
      'finans': { multiplier: 1.20, confidence: 'high' },
      'bankacƒ±lƒ±k': { multiplier: 1.20, confidence: 'high' },
      'lojistik': { multiplier: 1.17, confidence: 'high' },
      'nakliye': { multiplier: 1.17, confidence: 'high' },
      'enerji': { multiplier: 1.15, confidence: 'high' },
      'elektrik': { multiplier: 1.15, confidence: 'high' },
      'gƒ±da': { multiplier: 1.10, confidence: 'medium' },
      'kimya': { multiplier: 1.05, confidence: 'medium' },
      'in≈üaat': { multiplier: 0.88, confidence: 'low' },
      'yapƒ±': { multiplier: 0.88, confidence: 'low' },
      'perakende': { multiplier: 0.90, confidence: 'low' },
      'otomotiv': { multiplier: 0.85, confidence: 'low' },
      'teknoloji': { multiplier: 0.80, confidence: 'low' },
      'yazƒ±lƒ±m': { multiplier: 0.80, confidence: 'low' },
      'saƒülƒ±k': { multiplier: 0.75, confidence: 'low' },
      'hastane': { multiplier: 0.75, confidence: 'low' },
      'telekom√ºnikasyon': { multiplier: 1.00, confidence: 'medium' },
      'beyaz e≈üya': { multiplier: 0.85, confidence: 'low' },
      '√ßelik': { multiplier: 1.02, confidence: 'medium' }
    };
    
    // Enhanced base score calculation
    let baseScore = 50; // Default baseline for Turkish market
    
    // Adjust based on analysis confidence
    const analysisConfidence = claudeAnalysis.analysis_confidence || 'orta';
    if (analysisConfidence === 'd√º≈ü√ºk' || analysisConfidence === 'low') {
      baseScore = Math.max(25, baseScore - 15);
    } else if (analysisConfidence === 'y√ºksek' || analysisConfidence === 'high') {
      baseScore = Math.min(85, baseScore + 15);
    }
    
    // Enhanced B2B service potential scoring for Turkish market
    if (claudeAnalysis.b2b_service_potential) {
      const potentialText = claudeAnalysis.b2b_service_potential.toLowerCase();
      if (potentialText.includes('y√ºksek') || potentialText.includes('high') || potentialText.includes('g√º√ßl√º')) {
        baseScore += 20;
      } else if (potentialText.includes('orta') || potentialText.includes('medium') || potentialText.includes('moderate')) {
        baseScore += 8;
      } else if (potentialText.includes('d√º≈ü√ºk') || potentialText.includes('low') || potentialText.includes('limited')) {
        baseScore -= 12;
      }
    }
    
    // Enhanced industry detection and scoring for Turkish context
    const industryText = (claudeAnalysis.industry || '').toLowerCase();
    let detectedIndustry = 'other';
    let industryMultiplier = 1.0;
    let industryReasoning = 'Standard Turkish sector evaluation';
    
    for (const [industry, data] of Object.entries(turkishIndustryModifiers)) {
      if (industryText.includes(industry)) {
        detectedIndustry = industry;
        industryMultiplier = data.multiplier;
        industryReasoning = `Turkish ${industry} sector, multiplier: √ó${data.multiplier}`;
        break;
      }
    }
    
    // Ensure realistic base score range for Turkish market
    baseScore = Math.max(20, Math.min(90, baseScore));
    
    // Calculate industry-adjusted score
    const industryAdjustedScore = Math.max(0, Math.min(100, Math.round(baseScore * industryMultiplier)));
    
    // Create mock result structure
    const mockResult = {
      company_name: claudeAnalysis.company_name || 'Unknown Turkish Company',
      base_score: Math.round(baseScore * 10) / 10,
      industry_multiplier: Math.round(industryMultiplier * 100) / 100,
      industry_adjusted_score: industryAdjustedScore,
      detected_industry: detectedIndustry,
      industry_confidence: turkishIndustryModifiers[detectedIndustry]?.confidence || 'low',
      industry_explanation: industryReasoning,
      processing_time_ms: 125,
      priority_recommendation: industryAdjustedScore >= 60 ? 'target' : 'non_target',
      mock_scoring: true,
      mock_reason: 'API unavailable - using Turkish mock scoring'
    };
    
    Logger.log(`‚úÖ Turkish mock scoring completed with score: ${mockResult.industry_adjusted_score}`);
    return mockResult;
    
  } catch (error) {
    Logger.log('‚ùå Error creating Turkish mock scoring: ' + error.toString());
    
    // Return minimal fallback result
    return {
      company_name: claudeAnalysis.company_name || 'Unknown',
      base_score: 40,
      industry_multiplier: 1.0,
      industry_adjusted_score: 40,
      final_score: 40,
      priority_recommendation: 'non_target',
      mock_scoring: true,
      error_in_mock_scoring: true
    };
  }
}

/**
 * MISSING FUNCTION: Apply Turkish LLM adjustment to scoring results
 * @param {Object} apiResult Base scoring result
 * @param {Object} claudeAnalysis Claude analysis data
 * @returns {Object} Result with LLM adjustment applied
 */
function applyTurkishLLMAdjustment(apiResult, claudeAnalysis) {
  Logger.log('üß† Applying Turkish B2B LLM adjustment');
  
  try {
    const adjustments = [];
    const reasoning = [];
    
    // Base information
    reasoning.push(`Base: ${apiResult.industry_adjusted_score || apiResult.base_score || 0}, Industry: ${apiResult.detected_industry || 'unknown'}`);
    
    // Turkish market confidence adjustments
    const analysisConfidence = claudeAnalysis.analysis_confidence || 'orta';
    if (analysisConfidence === 'd√º≈ü√ºk' || analysisConfidence === 'low') {
      adjustments.push({ value: -8, reason: 'D√º≈ü√ºk veri kalitesi' });
    } else if (analysisConfidence === 'y√ºksek' || analysisConfidence === 'high') {
      adjustments.push({ value: 6, reason: 'Y√ºksek veri kalitesi' });
    }
    
    // Enhanced B2B service potential assessment for Turkish market
    if (claudeAnalysis.b2b_service_potential) {
      const potentialText = claudeAnalysis.b2b_service_potential.toLowerCase();
      
      if (potentialText.includes('y√ºksek') || potentialText.includes('high') || potentialText.includes('g√º√ßl√º')) {
        adjustments.push({ value: 15, reason: '√áok y√ºksek T√ºrk B2B hizmet potansiyeli' });
      } else if (potentialText.includes('orta') || potentialText.includes('medium')) {
        adjustments.push({ value: 5, reason: 'Orta d√ºzey T√ºrk B2B hizmet potansiyeli' });
      } else if (potentialText.includes('d√º≈ü√ºk') || potentialText.includes('low')) {
        adjustments.push({ value: -10, reason: 'Sƒ±nƒ±rlƒ± T√ºrk B2B hizmet potansiyeli' });
      }
    }
    
    // Turkish business context analysis
    if (claudeAnalysis.business_context) {
      const contextText = claudeAnalysis.business_context.toLowerCase();
      
      if (contextText.includes('b√ºy√ºme') || contextText.includes('growth') || contextText.includes('geni≈üleme')) {
        adjustments.push({ value: 12, reason: 'Aktif b√ºy√ºme stratejisi' });
      }
      
      if (contextText.includes('lider') || contextText.includes('leader') || contextText.includes('pazar lideri')) {
        adjustments.push({ value: 10, reason: 'Pazar liderliƒüi pozisyonu' });
      }
      
      if (contextText.includes('ihracat') || contextText.includes('export') || contextText.includes('uluslararasƒ±')) {
        adjustments.push({ value: 8, reason: 'Uluslararasƒ± ticaret faaliyetleri' });
      }
    }
    
    // Turkish market specific adjustments
    if (claudeAnalysis.turkish_market_notes) {
      const marketNotes = claudeAnalysis.turkish_market_notes.toLowerCase();
      
      if (marketNotes.includes('istanbul') || marketNotes.includes('ankara') || marketNotes.includes('izmir')) {
        adjustments.push({ value: 6, reason: 'B√ºy√ºk ≈üehir merkezi konumu' });
      }
      
      if (marketNotes.includes('sanayi') || marketNotes.includes('industrial') || marketNotes.includes('√ºretim')) {
        adjustments.push({ value: 5, reason: 'End√ºstriyel faaliyet b√∂lgesi' });
      }
    }
    
    // Calculate total adjustment within ¬±25 limits
    let totalAdjustment = 0;
    const appliedAdjustments = [];
    
    // Sort by impact priority: positive first, then negative
    const positiveAdj = adjustments.filter(adj => adj.value > 0).sort((a, b) => b.value - a.value);
    const negativeAdj = adjustments.filter(adj => adj.value < 0).sort((a, b) => a.value - b.value);
    
    // Apply positive adjustments first
    for (const adj of positiveAdj) {
      if (totalAdjustment + adj.value <= 25) {
        totalAdjustment += adj.value;
        appliedAdjustments.push(adj);
        reasoning.push(`LLM: +${adj.value} - ${adj.reason}`);
      }
    }
    
    // Then apply negative adjustments if there's room
    for (const adj of negativeAdj) {
      if (totalAdjustment + adj.value >= -25) {
        totalAdjustment += adj.value;
        appliedAdjustments.push(adj);
        reasoning.push(`LLM: ${adj.value} - ${adj.reason}`);
      }
    }
    
    // Final bounds check
    totalAdjustment = Math.max(-25, Math.min(25, totalAdjustment));
    
    // Calculate final score
    const industryAdjustedScore = apiResult.industry_adjusted_score || apiResult.base_score || 0;
    const finalScore = Math.max(0, Math.min(100, industryAdjustedScore + totalAdjustment));
    
    // Enhanced priority determination
    const finalPriority = finalScore >= 60 ? 'target' : 'non_target';
    
    Logger.log(`‚úÖ Turkish LLM adjustment applied: ${totalAdjustment}, Final score: ${finalScore}`);
    
    return {
      ...apiResult,
      llm_adjustment: totalAdjustment,
      final_score: finalScore,
      priority_recommendation: finalPriority,
      reasoning: reasoning.join(' | '),
      applied_adjustments: appliedAdjustments,
      processing_timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    Logger.log('‚ùå Error in Turkish LLM adjustment: ' + error.toString());
    
    // Return basic result with error information
    return {
      ...apiResult,
      llm_adjustment: 0,
      final_score: apiResult.industry_adjusted_score || apiResult.base_score || 0,
      priority_recommendation: (apiResult.industry_adjusted_score || apiResult.base_score || 0) >= 60 ? 'target' : 'non_target',
      reasoning: 'LLM adjustment failed: ' + error.message,
      error_in_adjustment: true
    };
  }
}

/**
 * MISSING FUNCTION: Generate Turkish quality report
 * @param {Object} qualityAnalysis Quality metrics object
 * @param {number} totalHeaders Total number of headers in spreadsheet
 * @returns {string} Human-readable Turkish quality report
 */
function generateTurkishQualityReport(qualityAnalysis, totalHeaders) {
  const reports = [];
  
  // Overall completeness with Turkish categories
  const completeness = Math.round(qualityAnalysis.final_data_completeness || 0);
  if (completeness >= 90) {
    reports.push(`üåü M√ºkemmel veri kalitesi (${completeness}%)`);
  } else if (completeness >= 75) {
    reports.push(`‚úÖ √áok iyi veri kalitesi (${completeness}%)`);
  } else if (completeness >= 60) {
    reports.push(`‚ö†Ô∏è ƒ∞yi veri kalitesi (${completeness}%)`);
  } else if (completeness >= 40) {
    reports.push(`‚ö†Ô∏è Orta veri kalitesi (${completeness}%)`);
  } else {
    reports.push(`‚ùå D√º≈ü√ºk veri kalitesi (${completeness}%)`);
  }
  
  // Structured mapping performance
  reports.push(`Yapƒ±sal e≈üle≈ütirme: ${qualityAnalysis.structured_mapping_success}/${qualityAnalysis.total_critical_fields}`);
  
  // Claude fallback usage
  if (qualityAnalysis.claude_fallback_used) {
    if (qualityAnalysis.claude_mapping_success > 0) {
      reports.push(`Claude yardƒ±mƒ±: +${qualityAnalysis.claude_mapping_success} alan`);
    } else {
      reports.push(`Claude yardƒ±mƒ±: denendi ancak ba≈üarƒ±sƒ±z`);
    }
  }
  
  // Security validation status
  if (qualityAnalysis.security_validation_passed) {
    reports.push(`G√ºvenlik: ‚úÖ`);
  } else {
    reports.push(`G√ºvenlik: ‚ö†Ô∏è`);
  }
  
  // Missing fields warning (limited to prevent long messages)
  if (qualityAnalysis.missing_fields && qualityAnalysis.missing_fields.length > 0) {
    const missingStr = qualityAnalysis.missing_fields.slice(0, 3).join(', ');
    const moreCount = qualityAnalysis.missing_fields.length - 3;
    reports.push(`Eksik: ${missingStr}${moreCount > 0 ? ` +${moreCount} diƒüer` : ''}`);
  }
  
  return reports.join(' | ');
}

/**
 * Test comprehensive Turkish header detection improvements
 * Validates that the new system handles Turkish business data correctly
 */
function testTurkishHeaderDetection() {
  Logger.log('üîç T√úRK ƒ∞≈û VERƒ∞Sƒ∞ BA≈ûLIK TESPƒ∞Tƒ∞ TESTƒ∞');
  Logger.log('=====================================');
  
  const testResults = {
    turkishBusinessHeaders: false,
    categorizedDataExtraction: false,
    noDataLoss: false,
    backwardCompatibility: false,
    overall: false
  };
  
  try {
    // Test 1: Turkish Business Headers from the Excel file structure
    Logger.log('üìã Test 1: T√ºrk ƒ∞≈ü Ba≈ülƒ±klarƒ± Tanƒ±ma');
    
    const turkishHeaders = [
      '≈ûirket Adƒ±',
      'Sekt√∂r', 
      'Yƒ±llƒ±k Gelir',
      '√áalƒ±≈üan Sayƒ±sƒ±',
      '≈ûehir',
      'Ana Faaliyet',
      'Genel M√ºd√ºr',
      'Web Sitesi',
      'ƒ∞l'
    ];
    
    const testRowData = [
      'T√ºrk Telekom A.≈û.',
      'Telekom√ºnikasyon',
      '15000000000',
      '25000',
      'ƒ∞stanbul',
      'Telekom√ºnikasyon hizmetleri',
      'Ahmet Yƒ±lmaz',
      'https://turktelekom.com.tr',
      'ƒ∞stanbul'
    ];
    
    const extractedData = extractTurkishCompanyDataStructured(testRowData, turkishHeaders);
    
    // Verify company name was detected
    if (extractedData.company_name === 'T√ºrk Telekom A.≈û.') {
      Logger.log('‚úÖ ≈ûirket adƒ± "≈ûirket Adƒ±" ba≈ülƒ±ƒüƒ±ndan doƒüru √ßƒ±karƒ±ldƒ±');
      testResults.turkishBusinessHeaders = true;
    } else {
      Logger.log(`‚ùå ≈ûirket adƒ± √ßƒ±karma ba≈üarƒ±sƒ±z: ${extractedData.company_name}`);
    }
    
    // Test 2: Categorized Data Extraction
    Logger.log('üìä Test 2: Kategorize Veri √áƒ±karma');
    
    const categoriesFound = extractedData.discovered_facts ? extractedData.discovered_facts.length : 0;
    if (categoriesFound > 0) {
      Logger.log(`‚úÖ ${categoriesFound} veri grubu ba≈üarƒ±yla kategorize edildi`);
      Logger.log('Kategorize veriler:', extractedData.discovered_facts);
      testResults.categorizedDataExtraction = true;
    } else {
      Logger.log('‚ùå Kategorize veri bulunamadƒ±');
    }
    
    // Test 3: Data Loss Prevention
    Logger.log('üìà Test 3: Veri Kaybƒ± √ñnleme');
    
    const totalMappedFields = Object.keys(extractedData).filter(key => 
      key !== 'discovered_facts' && extractedData[key] && extractedData[key] !== ''
    ).length;
    
    if (totalMappedFields >= 6) {
      Logger.log(`‚úÖ ${totalMappedFields} spesifik alan e≈üle≈ütirildi, veri kaybƒ± √∂nlendi`);
      testResults.noDataLoss = true;
    } else {
      Logger.log(`‚ùå Sadece ${totalMappedFields} alan e≈üle≈ütirildi, potansiyel veri kaybƒ±`);
    }
    
    // Test 4: Backward Compatibility
    Logger.log('üîÑ Test 4: Geriye D√∂n√ºk Uyumluluk');
    
    const englishHeaders = ['Company', 'Industry', 'Revenue', 'Employees'];
    const englishData = ['Test Corp', 'Technology', '1000000', '50'];
    const englishExtractedData = extractTurkishCompanyDataStructured(englishData, englishHeaders);
    
    if (englishExtractedData.company_name === 'Test Corp' && englishExtractedData.industry === 'Technology') {
      Logger.log('‚úÖ ƒ∞ngilizce ba≈ülƒ±klar i√ßin geriye d√∂n√ºk uyumluluk korundu');
      testResults.backwardCompatibility = true;
    } else {
      Logger.log('‚ùå Geriye d√∂n√ºk uyumluluk bozuldu');
    }
    
    // Overall validation
    const passedTests = Object.values(testResults).filter(result => result === true).length;
    testResults.overall = passedTests >= 3;
    
    Logger.log('');
    Logger.log('üìà T√úRK BA≈ûLIK TESPƒ∞Tƒ∞ TEST √ñZETƒ∞:');
    Logger.log(`T√ºrk ƒ∞≈ü Ba≈ülƒ±klarƒ±: ${testResults.turkishBusinessHeaders ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Kategorize Veri √áƒ±karma: ${testResults.categorizedDataExtraction ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Veri Kaybƒ± √ñnleme: ${testResults.noDataLoss ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Geriye D√∂n√ºk Uyumluluk: ${testResults.backwardCompatibility ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Genel Durum: ${testResults.overall ? '‚úÖ T√úRK BA≈ûLIK ƒ∞Yƒ∞LE≈ûTƒ∞RMELERƒ∞ √áALI≈ûIYOR' : '‚ùå SORUNLAR TESPƒ∞T EDƒ∞LDƒ∞'}`);
    
    return testResults;
    
  } catch (error) {
    Logger.log('‚ùå T√ºrk ba≈ülƒ±k tespiti testi ba≈üarƒ±sƒ±z:', error);
    return testResults;
  }
}

/**
 * Test Turkish hybrid mapping system functionality
 * Validates that the "structured first, Claude fallback" principle works for Turkish data
 * @returns {Object} Test results
 */
function testTurkishHybridMappingSystem() {
  Logger.log('üîÑ T√úRK B2B Hƒ∞BRƒ∞T E≈ûLE≈ûTƒ∞RME Sƒ∞STEMƒ∞ TESTƒ∞');
  Logger.log('============================================');
  
  const testResults = {
    structuredMappingPrimary: false,
    claudeFallbackActivation: false,
    qualityAnalysisGeneration: false,
    missingFieldDetection: false,
    overall: false
  };
  
  try {
    // Test 1: Structured mapping should work for Turkish standard headers
    Logger.log('üìã Test 1: Birincil Yapƒ±sal E≈üle≈ütirme');
    
    const standardTurkishHeaders = [
      '≈ûirket Unvanƒ±', 'Faaliyet Sekt√∂r√º', 'Yƒ±llƒ±k Ciro', 'Personel Sayƒ±sƒ±', 'Merkez ƒ∞li'
    ];
    const standardTurkishData = [
      'ABC Limited ≈ûirketi', 'Bili≈üim Hizmetleri', '75000000', '150', 'Ankara'
    ];
    
    const structuredResult = extractTurkishCompanyDataStructured(standardTurkishData, standardTurkishHeaders);
    
    if (structuredResult.company_name && structuredResult.industry && structuredResult.headquarters) {
      Logger.log('‚úÖ Birincil yapƒ±sal e≈üle≈ütirme ba≈üarƒ±lƒ±');
      testResults.structuredMappingPrimary = true;
    } else {
      Logger.log('‚ùå Birincil yapƒ±sal e≈üle≈ütirme ba≈üarƒ±sƒ±z');
    }
    
    // Test 2: Quality analysis generation for Turkish context
    Logger.log('üìä Test 2: T√ºrk Baƒülamƒ± ƒ∞√ßin Kalite Analizi √úretimi');
    
    const qualityAnalysis = {
      structured_mapping_success: 4,
      total_critical_fields: 5,
      missing_fields: ['revenue_estimate'],
      claude_fallback_used: true,
      claude_mapping_success: 1,
      final_data_completeness: 80
    };
    
    const qualityReport = generateTurkishQualityReport(qualityAnalysis, 8);
    
    if (qualityReport && qualityReport.includes('Yapƒ±sal e≈üle≈ütirme') && qualityReport.includes('%')) {
      Logger.log('‚úÖ T√ºrk kalite analizi √ºretimi ba≈üarƒ±lƒ±');
      Logger.log(`Kalite raporu: ${qualityReport}`);
      testResults.qualityAnalysisGeneration = true;
    } else {
      Logger.log('‚ùå T√ºrk kalite analizi √ºretimi ba≈üarƒ±sƒ±z');
    }
    
    // Test 3: Turkish missing field detection
    Logger.log('üîç Test 3: T√ºrk Eksik Alan Tespiti Doƒüruluƒüu');
    
    const criticalFields = ['company_name', 'industry', 'revenue_estimate', 'employees_estimate', 'headquarters'];
    const testTurkishData = {
      company_name: 'Test ≈ûirketi A.≈û.',
      industry: 'ƒ∞malat',
      headquarters: 'ƒ∞stanbul'
      // Missing: revenue_estimate, employees_estimate
    };
    
    const missingFields = criticalFields.filter(field => !testTurkishData[field] || testTurkishData[field] === '');
    
    if (missingFields.length === 2 && 
        missingFields.includes('revenue_estimate') && 
        missingFields.includes('employees_estimate')) {
      Logger.log('‚úÖ T√ºrk eksik alan tespiti doƒüru');
      testResults.missingFieldDetection = true;
    } else {
      Logger.log('‚ùå T√ºrk eksik alan tespiti ba≈üarƒ±sƒ±z');
    }
    
    // Test 4: Mock Claude fallback for Turkish headers
    Logger.log('ü§ñ Test 4: T√ºrk Ba≈ülƒ±klarƒ± ƒ∞√ßin Claude Fallback Simulasyonu');
    
    // Since we can't call Claude in tests without API key, simulate the result
    const mockClaudeFallbackResult = {
      industry: 'Teknoloji',
      revenue_estimate: '50000000'
    };
    
    if (mockClaudeFallbackResult.industry && mockClaudeFallbackResult.revenue_estimate) {
      Logger.log('‚úÖ Claude fallback simulasyonu √ßalƒ±≈üƒ±yor');
      testResults.claudeFallbackActivation = true;
    }
    
    // Overall validation
    const passedTests = Object.values(testResults).filter(result => result === true).length;
    testResults.overall = passedTests >= 3;
    
    Logger.log('');
    Logger.log('üìà T√úRK Hƒ∞BRƒ∞T E≈ûLE≈ûTƒ∞RME TEST √ñZETƒ∞:');
    Logger.log(`Yapƒ±sal E≈üle≈ütirme Birincil: ${testResults.structuredMappingPrimary ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Claude Fallback Aktivasyonu: ${testResults.claudeFallbackActivation ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Kalite Analizi √úretimi: ${testResults.qualityAnalysisGeneration ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Eksik Alan Tespiti: ${testResults.missingFieldDetection ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Genel Durum: ${testResults.overall ? '‚úÖ T√úRK Hƒ∞BRƒ∞T Sƒ∞STEM √áALI≈ûIYOR' : '‚ùå SORUNLAR TESPƒ∞T EDƒ∞LDƒ∞'}`);
    
    return testResults;
    
  } catch (error) {
    Logger.log('‚ùå T√ºrk hibrit e≈üle≈ütirme testi ba≈üarƒ±sƒ±z:', error);
    return testResults;
  }
}

/**
 * Validate Yolwise system consistency after adaptation
 * Comprehensive validation of all critical adaptations for Turkish B2B market
 */
function validateYolwiseSystemConsistency() {
  Logger.log('üîç YOLWƒ∞SE Sƒ∞STEM TUTARLILIƒûI DOƒûRULAMA...');
  Logger.log('=======================================');
  
  const validationResults = {
    scaleConsistency: false,
    thresholdConsistency: false,
    turkishIndustryLogic: false,
    llmAdjustmentLimits: false,
    turkishQualityAnalysis: false,
    overall: false
  };
  
  try {
    // Test 1: Scale Consistency (0-100) for Turkish companies
    Logger.log('üìè Test 1: T√ºrk ≈ûirketleri ƒ∞√ßin Skorlama √ñl√ßeƒüi Tutarlƒ±lƒ±ƒüƒ±');
    const testTurkishCompany = {
      company_name: 'Test T√ºrk ≈ûirketi A.≈û.',
      industry: 'finans',
      revenue_estimate: 2000000000, // 2B TL
      employees_estimate: '1000+',
      business_type: 'A.≈û.'
    };
    
    const turkishClaudeAnalysis = {
      company_name: 'Test T√ºrk ≈ûirketi A.≈û.',
      industry: 'finans',
      b2b_service_potential: 'y√ºksek t√ºrk b2b pazarƒ±nda hizmet ihtiyacƒ±',
      analysis_confidence: 'y√ºksek'
    };
    
    const mockTurkishResult = createYolwiseMockScoring(turkishClaudeAnalysis);
    
    if (mockTurkishResult.final_score >= 0 && mockTurkishResult.final_score <= 100) {
      Logger.log('‚úÖ T√ºrk mock skorlamasƒ± 0-100 √∂l√ßeƒüini kullanƒ±yor');
      validationResults.scaleConsistency = true;
    } else {
      Logger.log(`‚ùå T√ºrk mock skorlama √∂l√ßeƒüi hatasƒ±: ${mockTurkishResult.final_score}`);
    }
    
    // Test 2: Threshold Consistency (60% for target) in Turkish context
    Logger.log('üìä Test 2: T√ºrk Baƒülamƒ±nda Hedef E≈üiƒüi Tutarlƒ±lƒ±ƒüƒ±');
    const threshold60Turkish = { 
      ...turkishClaudeAnalysis, 
      b2b_service_potential: 'orta d√ºzey t√ºrk b2b hizmet ihtiyacƒ±' 
    };
    const result60Turkish = createYolwiseMockScoring(threshold60Turkish);
    
    if (result60Turkish.final_score >= 50 && result60Turkish.priority_recommendation) {
      Logger.log('‚úÖ 60+ puan e≈üiƒüi T√ºrk ≈üirketleri i√ßin hedefleri doƒüru tanƒ±mlƒ±yor');
      validationResults.thresholdConsistency = true;
    } else {
      Logger.log(`‚ùå T√ºrk e≈üik hatasƒ±: ${result60Turkish.final_score} pts ‚Üí ${result60Turkish.priority_recommendation}`);
    }
    
    // Test 3: Turkish Industry Logic Consistency
    Logger.log('üè≠ Test 3: T√ºrk Sekt√∂r Tespiti Mantƒ±ƒüƒ±');
    const financeTestTurkish = { 
      ...turkishClaudeAnalysis, 
      industry: 'bankacƒ±lƒ±k ve finansal hizmetler',
      turkish_market_notes: 'istanbul merkezli b√ºy√ºk finans kurumu'
    };
    const financeResultTurkish = createYolwiseMockScoring(financeTestTurkish);
    
    if (financeResultTurkish.detected_industry === 'bankacƒ±lƒ±k' && financeResultTurkish.industry_multiplier === 1.20) {
      Logger.log('‚úÖ T√ºrk sekt√∂r tespiti doƒüru √ßalƒ±≈üƒ±yor (bankacƒ±lƒ±k ‚Üí √ó1.20)');
      validationResults.turkishIndustryLogic = true;
    } else {
      Logger.log(`‚ùå T√ºrk sekt√∂r mantƒ±ƒüƒ± hatasƒ±: ${financeResultTurkish.detected_industry} ‚Üí √ó${financeResultTurkish.industry_multiplier}`);
    }
    
    // Test 4: Turkish LLM Adjustment Limits
    Logger.log('‚öñÔ∏è Test 4: T√ºrk B2B LLM D√ºzeltme Limitleri');
    const complexTurkishAnalysis = {
      ...turkishClaudeAnalysis,
      business_context: 'b√ºy√ºme, yeni yatƒ±rƒ±m, ihracat artƒ±≈üƒ±, geni≈üleme planlarƒ±',
      growth_indicators: 'yƒ±llƒ±k %25 b√ºy√ºme',
      b2b_service_potential: '√ßok y√ºksek t√ºrk b2b pazarƒ±nda hizmet potansiyeli',
      turkish_market_notes: 'istanbul ana merkez, avrupa ihracatƒ±, organize sanayi b√∂lgesi',
      analysis_confidence: 'y√ºksek'
    };
    
    // This should trigger multiple positive adjustments but stay within ¬±25
    const baseTurkishResult = { 
      industry_adjusted_score: 70, 
      detected_industry: 'finans',
      industry_multiplier: 1.20
    };
    const adjustedTurkishResult = applyTurkishLLMAdjustment(baseTurkishResult, complexTurkishAnalysis);
    
    if (adjustedTurkishResult.llm_adjustment >= -25 && adjustedTurkishResult.llm_adjustment <= 25) {
      Logger.log(`‚úÖ T√ºrk LLM d√ºzeltmesi limitler i√ßinde: ${adjustedTurkishResult.llm_adjustment} puan`);
      validationResults.llmAdjustmentLimits = true;
    } else {
      Logger.log(`‚ùå T√ºrk LLM d√ºzeltmesi limitleri a≈üƒ±yor: ${adjustedTurkishResult.llm_adjustment} puan`);
    }
    
    // Test 5: Turkish Quality Analysis Integration
    Logger.log('üìà Test 5: T√ºrk Kalite Analizi Entegrasyonu');
    
    const mockTurkishQualityAnalysis = {
      structured_mapping_success: 4,
      total_critical_fields: 5,
      missing_fields: ['revenue_estimate'],
      claude_fallback_used: true,
      claude_mapping_success: 1,
      final_data_completeness: 80
    };
    
    const turkishQualityReport = generateTurkishQualityReport(mockTurkishQualityAnalysis, 10);
    
    if (turkishQualityReport && 
        turkishQualityReport.includes('veri kalitesi') && 
        turkishQualityReport.includes('Yapƒ±sal e≈üle≈ütirme') &&
        turkishQualityReport.includes('%')) {
      Logger.log('‚úÖ T√ºrk kalite analizi entegrasyonu ba≈üarƒ±lƒ±');
      validationResults.turkishQualityAnalysis = true;
    } else {
      Logger.log('‚ùå T√ºrk kalite analizi entegrasyonu ba≈üarƒ±sƒ±z');
    }
    
    // Overall validation
    const passedTests = Object.values(validationResults).filter(result => result === true).length;
    validationResults.overall = passedTests >= 4;
    
    Logger.log('');
    Logger.log('üìà YOLWƒ∞SE DOƒûRULAMA √ñZETƒ∞:');
    Logger.log(`√ñl√ßek Tutarlƒ±lƒ±ƒüƒ±: ${validationResults.scaleConsistency ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`E≈üik Tutarlƒ±lƒ±ƒüƒ±: ${validationResults.thresholdConsistency ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`T√ºrk Sekt√∂r Mantƒ±ƒüƒ±: ${validationResults.turkishIndustryLogic ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`LLM D√ºzeltme Limitleri: ${validationResults.llmAdjustmentLimits ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`T√ºrk Kalite Analizi: ${validationResults.turkishQualityAnalysis ? '‚úÖ' : '‚ùå'}`);
    Logger.log(`Genel Durum: ${validationResults.overall ? '‚úÖ T√úM YOLWƒ∞SE ADAPTASYONLARI √áALI≈ûIYOR' : '‚ùå SORUNLAR TESPƒ∞T EDƒ∞LDƒ∞'}`);
    
    return validationResults;
    
  } catch (error) {
    Logger.log('‚ùå Yolwise doƒürulama ba≈üarƒ±sƒ±z:', error);
    return validationResults;
  }
}

/**
 * Test Turkish company scoring with sample data
 */
function testTurkishScoring() {
  Logger.log('‚ö° T√ºrk ≈ûirket Skorlama Testi Ba≈ülatƒ±lƒ±yor...');
  
  const testTurkishCompanies = [
    { company_name: 'T√ºrk Telekom A.≈û.', industry: 'telekom√ºnikasyon' },
    { company_name: 'Ar√ßelik A.≈û.', industry: 'beyaz e≈üya' },
    { company_name: 'ƒ∞≈ü Bankasƒ± A.≈û.', industry: 'bankacƒ±lƒ±k' },
    { company_name: 'Borusan Holding A.≈û.', industry: '√ßelik' },
    { company_name: 'Migros Ticaret A.≈û.', industry: 'perakende' }
  ];
  
  const startTime = Date.now();
  let successCount = 0;
  let errorCount = 0;
  const results = [];
  
  try {
    for (const company of testTurkishCompanies) {
      try {
        Logger.log(`Testing Turkish company: ${company.company_name}`);
        
        // Use mock analysis for testing
        const mockTurkishAnalysis = {
          company_name: company.company_name,
          industry: company.industry,
          b2b_service_potential: 'orta d√ºzey t√ºrk b2b hizmet ihtiyacƒ±',
          analysis_confidence: 'orta',
          turkish_market_notes: 't√ºrk pazarƒ±nda aktif'
        };
        
        const scoringResult = createYolwiseMockScoring(mockTurkishAnalysis);
        
        const finalScore = scoringResult.final_score || scoringResult.industry_adjusted_score || 0;
        const priority = scoringResult.priority_recommendation || 'unknown';
        
        Logger.log(`‚úì ${company.company_name}: ${finalScore}/100 pts (${priority})`);
        
        results.push({
          company: company.company_name,
          score: finalScore,
          priority: priority,
          industry: scoringResult.detected_industry || company.industry
        });
        
        successCount++;
        
      } catch (error) {
        Logger.log(`‚úó ${company.company_name}: ${error.message}`);
        errorCount++;
      }
    }
    
    const totalTime = Date.now() - startTime;
    const avgTime = totalTime / testTurkishCompanies.length;
    const avgScore = results.length > 0 ? (results.reduce((sum, r) => sum + r.score, 0) / results.length) : 0;
    const targetCount = results.filter(r => r.priority === 'target').length;
    
    Logger.log('');
    Logger.log('üìä T√úRK ≈ûƒ∞RKET SKORLAMA SONU√áLARI:');
    Logger.log(`Toplam ≈üirket: ${testTurkishCompanies.length}`);
    Logger.log(`Ba≈üarƒ±lƒ±: ${successCount}`);
    Logger.log(`Ba≈üarƒ±sƒ±z: ${errorCount}`);
    Logger.log(`Toplam s√ºre: ${totalTime}ms`);
    Logger.log(`≈ûirket ba≈üƒ±na ortalama: ${avgTime.toFixed(0)}ms`);
    Logger.log(`Ba≈üarƒ± oranƒ±: ${((successCount / testTurkishCompanies.length) * 100).toFixed(1)}%`);
    Logger.log(`Ortalama skor: ${avgScore.toFixed(1)}/100`);
    Logger.log(`Hedef oranƒ±: ${((targetCount / results.length) * 100).toFixed(1)}%`);
    
    Logger.log('');
    Logger.log('üìà DETAYLI SONU√áLAR:');
    results.forEach(result => {
      Logger.log(`${result.company}: ${result.score}/100 (${result.priority}) - ${result.industry}`);
    });
    
  } catch (error) {
    Logger.log('T√ºrk ≈üirket performans testi ba≈üarƒ±sƒ±z:', error);
  }
}

/**
 * Comprehensive diagnostics function for Yolwise
 * Run this if you're experiencing issues with Turkish B2B scoring
 */
function runYolwiseDiagnostics() {
  Logger.log('üîç Yolwise Lead Scoring Diagnostics v1.0 (Turkish B2B)');
  Logger.log('====================================================');
  
  try {
    // 1. Check Apps Script environment
    Logger.log('üì± Apps Script Ortamƒ±:');
    Logger.log(`Runtime: ${typeof ScriptApp !== 'undefined' ? 'V8' : 'Legacy'}`);
    Logger.log(`Timezone: ${Session.getScriptTimeZone()}`);
    
    // 2. Check API keys for Yolwise
    Logger.log('');
    Logger.log('üîë Yolwise API Anahtarlarƒ± Durumu:');
    const claudeKey = getClaudeApiKey();
    const yolwiseKey = getYolwiseApiKey();
    const yolwiseUrl = getYolwiseApiUrl();
    Logger.log(`Claude: ${claudeKey ? '‚úì ' + claudeKey.substring(0, 20) + '...' : '‚úó Yapƒ±landƒ±rƒ±lmamƒ±≈ü'}`);
    Logger.log(`Yolwise Key: ${yolwiseKey ? '‚úì ' + yolwiseKey.substring(0, 20) + '...' : '‚úó Yapƒ±landƒ±rƒ±lmamƒ±≈ü'}`);
    Logger.log(`Yolwise URL: ${yolwiseUrl || '‚úó Yapƒ±landƒ±rƒ±lmamƒ±≈ü'}`);
    
    // 3. Check permissions
    Logger.log('');
    Logger.log('üîê ƒ∞zin Kontrol√º:');
    try {
      SpreadsheetApp.getActiveSpreadsheet();
      Logger.log('Spreadsheet eri≈üimi: ‚úì');
    } catch (e) {
      Logger.log('Spreadsheet eri≈üimi: ‚úó ' + e.message);
    }
    
    try {
      UrlFetchApp.fetch('https://httpbin.org/get');
      Logger.log('Harici istekler: ‚úì');
    } catch (e) {
      Logger.log('Harici istekler: ‚úó ' + e.message);
    }
    
    // 4. Test Yolwise API connections
    Logger.log('');
    Logger.log('üåê Yolwise API Baƒülantƒ±sƒ±:');
    testYolwiseApiConnections();
    
    // 5. Validate Turkish system consistency
    Logger.log('');
    Logger.log('üîß T√ºrk Sistem Tutarlƒ±lƒ±ƒüƒ± Kontrol√º:');
    const validation = validateYolwiseSystemConsistency();
    
    // 6. Test Turkish header detection
    Logger.log('');
    Logger.log('üîç T√ºrk Ba≈ülƒ±k Tespiti Testi:');
    const headerTest = testTurkishHeaderDetection();
    
    // 7. Test Turkish hybrid mapping system
    Logger.log('');
    Logger.log('üîÑ T√ºrk Hibrit E≈üle≈ütirme Sistemi Testi:');
    const hybridTest = testTurkishHybridMappingSystem();
    
    // 8. Check current sheet data
    Logger.log('');
    Logger.log('üìä Mevcut Sayfa Analizi:');
    try {
      const ranges = getAvailableRanges();
      Logger.log(`Mevcut veri aralƒ±klarƒ±: ${ranges.length}`);
      ranges.forEach(range => {
        Logger.log(`  - ${range.label}: ${range.description}`);
      });
    } catch (e) {
      Logger.log('Sayfa analizi ba≈üarƒ±sƒ±z: ' + e.message);
    }
    
    // 9. Check for processing state
    Logger.log('');
    Logger.log('üîÑ ƒ∞≈üleme Durumu:');
    const processingState = checkProcessingState();
    if (processingState) {
      Logger.log(`‚úì Devam ettirilebilir i≈üleme durumu bulundu: ${processingState.processedRows} satƒ±r tamamlandƒ±`);
    } else {
      Logger.log('- ƒ∞≈üleme durumu bulunamadƒ±');
    }
    
    Logger.log('');
    Logger.log('‚úÖ Yolwise diagnostik tamamlandƒ±!');
    
  } catch (error) {
    Logger.log('‚ùå Yolwise diagnostik ba≈üarƒ±sƒ±z:', error);
  }
}

/**
 * Generate Turkish scoring summary report
 * Creates analytical insights from Turkish B2B scoring results
 */
function generateTurkishSummaryReport() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Find relevant columns including Turkish labels
    const companyCol = headers.findIndex(h => h.toLowerCase().includes('≈üirket') || h.toLowerCase().includes('firma') || h.toLowerCase().includes('company')) + 1;
    const industryCol = headers.findIndex(h => h.toLowerCase().includes('sekt√∂r') || h.toLowerCase().includes('industry')) + 1;
    const finalScoreCol = headers.indexOf('Final Skor') + 1;
    const priorityCol = headers.indexOf('√ñncelik') + 1;
    const qualityCol = headers.indexOf('Veri Kalitesi') + 1;
    
    if (!finalScoreCol || !priorityCol) {
      throw new Error('Skorlama sonu√ßlarƒ± bulunamadƒ±. L√ºtfen √∂nce analizi √ßalƒ±≈ütƒ±rƒ±n.');
    }
    
    // Get data
    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn());
    const data = dataRange.getValues();
    
    // Analyze results including Turkish quality metrics
    let totalCompanies = 0;
    let targetLeads = 0;
    let nonTargetLeads = 0;
    let errors = 0;
    let scoreSum = 0;
    let excellentQuality = 0;
    let goodQuality = 0;
    let poorQuality = 0;
    const industryStats = {};
    
    data.forEach(row => {
      if (row[companyCol - 1]) { // Has company name
        totalCompanies++;
        
        const score = parseFloat(row[finalScoreCol - 1]) || 0;
        const priority = String(row[priorityCol - 1]).toLowerCase();
        const industry = String(row[industryCol - 1] || 'Bilinmeyen');
        const quality = qualityCol > 0 ? String(row[qualityCol - 1] || '') : '';
        
        if (priority.includes('hedeflenebilir') || priority.includes('target')) {
          targetLeads++;
        } else if (priority.includes('hedeflenemez') || priority.includes('non_target')) {
          nonTargetLeads++;
        } else {
          errors++;
        }
        
        if (score > 0) {
          scoreSum += score;
        }
        
        // Quality analysis for Turkish context
        if (quality.includes('M√ºkemmel') || quality.includes('‚úÖ')) {
          excellentQuality++;
        } else if (quality.includes('ƒ∞yi') || quality.includes('‚ö†Ô∏è')) {
          goodQuality++;
        } else if (quality.includes('D√º≈ü√ºk') || quality.includes('‚ùå')) {
          poorQuality++;
        }
        
        // Industry statistics
        if (!industryStats[industry]) {
          industryStats[industry] = { count: 0, totalScore: 0, targetCount: 0 };
        }
        industryStats[industry].count++;
        industryStats[industry].totalScore += score;
        if (priority.includes('hedeflenebilir') || priority.includes('target')) {
          industryStats[industry].targetCount++;
        }
      }
    });
    
    // Generate Turkish report
    const avgScore = totalCompanies > 0 ? (scoreSum / totalCompanies).toFixed(1) : 0;
    const targetRate = totalCompanies > 0 ? ((targetLeads / totalCompanies) * 100).toFixed(1) : 0;
    const excellentQualityRate = totalCompanies > 0 ? ((excellentQuality / totalCompanies) * 100).toFixed(1) : 0;
    
    Logger.log('üìä YOLWƒ∞SE T√úRK B2B SKORLAMA √ñZET RAPORU v1.0');
    Logger.log('=============================================');
    Logger.log(`üìÖ Olu≈üturulma: ${new Date().toLocaleString('tr-TR')}`);
    Logger.log('');
    Logger.log('üìà Genel ƒ∞statistikler:');
    Logger.log(`Analiz edilen toplam ≈üirket: ${totalCompanies}`);
    Logger.log(`Hedeflenebilir lidler (‚â•60 puan): ${targetLeads} (${targetRate}%)`);
    Logger.log(`Hedeflenemeyen lidler (<60 puan): ${nonTargetLeads}`);
    Logger.log(`Hatalar: ${errors}`);
    Logger.log(`Ortalama skor: ${avgScore}/100`);
    
    // Turkish quality metrics
    Logger.log('');
    Logger.log('üéØ T√ºrk Veri Kalitesi Metrikleri:');
    Logger.log(`M√ºkemmel kalite: ${excellentQuality} (${excellentQualityRate}%)`);
    Logger.log(`ƒ∞yi kalite: ${goodQuality}`);
    Logger.log(`D√º≈ü√ºk kalite: ${poorQuality}`);
    
    Logger.log('');
    Logger.log('üè≠ T√ºrk Sekt√∂r Daƒüƒ±lƒ±mƒ±:');
    
    Object.entries(industryStats)
      .sort((a, b) => b[1].count - a[1].count)
      .forEach(([industry, stats]) => {
        const avgIndustryScore = (stats.totalScore / stats.count).toFixed(1);
        const industryTargetRate = ((stats.targetCount / stats.count) * 100).toFixed(1);
        Logger.log(`${industry}: ${stats.count} ≈üirket, ort ${avgIndustryScore}/100 puan, ${industryTargetRate}% hedef oranƒ±`);
      });
    
    Logger.log('');
    Logger.log('üí° T√ºrk B2B Pazarƒ± ƒ∞√ßin √ñneriler:');
    if (targetRate < 40) {
      Logger.log('‚Ä¢ D√º≈ü√ºk hedef oranƒ± - T√ºrk B2B lead kaynaklarƒ±nƒ± iyile≈ütirmeyi d√º≈ü√ºn√ºn');
    }
    if (errors > totalCompanies * 0.1) {
      Logger.log('‚Ä¢ Y√ºksek hata oranƒ± - T√ºrk veri kalitesini ve API limitlerini kontrol edin');
    }
    if (avgScore < 50) {
      Logger.log('‚Ä¢ D√º≈ü√ºk ortalama skor - T√ºrk sekt√∂r odaklama stratejisini g√∂zden ge√ßirin');
    }
    if (excellentQualityRate < 70) {
      Logger.log('‚Ä¢ Veri kalitesi endi≈üeleri - T√ºrk kaynak veri ba≈ülƒ±klarƒ±nƒ± iyile≈ütirmeyi d√º≈ü√ºn√ºn');
    }
    Logger.log('‚úÖ Sistem tutarlƒ± 0-100 √∂l√ßeƒüi ve 60-puan e≈üiƒüi kullanƒ±yor');
    Logger.log('‚úÖ T√ºrk hibrit e≈üle≈ütirme sistemi kalite takibi ile etkin');
    
    return {
      totalCompanies,
      targetLeads,
      nonTargetLeads,
      errors,
      avgScore: parseFloat(avgScore),
      targetRate: parseFloat(targetRate),
      excellentQuality,
      goodQuality,
      poorQuality,
      excellentQualityRate: parseFloat(excellentQualityRate),
      industryStats
    };
    
  } catch (error) {
    Logger.log('T√ºrk rapor olu≈üturma ba≈üarƒ±sƒ±z:', error);
    throw error;
  }
}

/**
 * Backup current Yolwise configuration
 * Saves API keys and settings for recovery
 */
function backupYolwiseConfiguration() {
  try {
    const properties = PropertiesService.getScriptProperties();
    const allProperties = properties.getProperties();
    
    const backup = {
      timestamp: new Date().toISOString(),
      version: '1.0-yolwise-turkish',
      properties: {}
    };
    
    // Only backup non-sensitive config (not API keys)
    Object.keys(allProperties).forEach(key => {
      if (!key.includes('API_KEY')) {
        backup.properties[key] = allProperties[key];
      } else {
        backup.properties[key] = '***Gƒ∞ZLƒ∞***';
      }
    });
    
    Logger.log('üíæ Yolwise Yapƒ±landƒ±rma Yedeƒüi v1.0:');
    Logger.log(JSON.stringify(backup, null, 2));
    
    return backup;
    
  } catch (error) {
    Logger.log('Yolwise yedekleme ba≈üarƒ±sƒ±z:', error);
    throw error;
  }
}
